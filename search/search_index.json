{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to BrickLLM","text":"<p>BrickLLM is a Python library designed to generate RDF files that comply with the BrickSchema ontology using Large Language Models (LLMs).</p> <ul> <li>Overview</li> <li>Installation</li> <li>Usage</li> <li>API Reference</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>BrickLLM can be installed using pip.</p> <pre><code>pip install brickllm\n</code></pre> <p>Alternatively, using Poetry, which handles dependency management.</p> <pre><code># Clone the repository\ngit clone https://github.com/EURAC-EEBgroup/brickllm-lib.git\ncd brickllm-lib\n\n# Install dependencies\npoetry install\n</code></pre>"},{"location":"overview/","title":"Overview","text":"<p>BrickLLM is a Python library designed to generate RDF (Resource Description Framework) files that comply with the BrickSchema ontology using Large Language Models (LLMs). The library leverages advanced natural language processing capabilities to interpret building descriptions and convert them into structured, machine-readable formats suitable for building automation and energy management systems.</p>"},{"location":"overview/#main-features","title":"Main Features","text":"<ul> <li>Multi-provider LLM Support: Supports multiple LLM providers, including OpenAI, Anthropic, and Fireworks AI.</li> <li>Natural Language to RDF Conversion: Converts natural language descriptions of buildings and facilities into BrickSchema-compliant RDF.</li> <li>Customizable Graph Execution: Utilizes LangGraph for flexible and customizable graph-based execution of the conversion process.</li> <li>Ontology Integration: Incorporates the BrickSchema ontology for accurate and standardized representation of building systems.</li> <li>Extensible Architecture: Designed with modularity in mind, allowing for easy extension and customization.</li> </ul>"},{"location":"overview/#how-it-works","title":"How It Works","text":"<ol> <li> <p>User Input: The process begins with a natural language description of a building or facility provided by the user.</p> </li> <li> <p>LLM Processing: The description is processed by a selected LLM to extract relevant building components and their relationships.</p> </li> <li> <p>Graph Execution: The extracted information is passed through a series of nodes in a graph structure:</p> </li> <li>Element Identification: Identifies building elements from the user prompt.</li> <li>Hierarchy Construction: Builds a hierarchical structure of the identified elements.</li> <li>Relationship Mapping: Determines relationships between the components.</li> <li> <p>TTL Generation: Converts the structured data into Turtle (TTL) format, which is a serialization of RDF.</p> </li> <li> <p>Output Generation: The final output is a BrickSchema-compliant RDF file in TTL format, representing the building's structure and systems.</p> </li> </ol>"},{"location":"usage/","title":"Usage","text":""},{"location":"modules/brickllm/","title":"BrickLLM Module","text":"<p>The <code>brickllm</code> package is the main package containing all modules and components related to generating BrickSchema-compliant RDF files using LLMs.</p>"},{"location":"modules/brickllm/#contents","title":"Contents","text":""},{"location":"modules/brickllm/#edges","title":"Edges","text":"<ul> <li>validate_condition.py</li> </ul>"},{"location":"modules/brickllm/#graphs","title":"Graphs","text":"<ul> <li>brickschema_graph.py</li> </ul>"},{"location":"modules/brickllm/#helpers","title":"Helpers","text":"<ul> <li>llm_models.py</li> <li>prompts.py</li> </ul>"},{"location":"modules/brickllm/#nodes","title":"Nodes","text":"<ul> <li>get_elem_children.py</li> <li>get_elements.py</li> <li>get_relationships.py</li> <li>get_sensors.py</li> <li>schema_to_ttl.py</li> <li>validate_schema.py</li> </ul>"},{"location":"modules/brickllm/#ontologies","title":"Ontologies","text":"<ul> <li>brick_hierarchy.json</li> <li>Brick.ttl</li> </ul>"},{"location":"modules/brickllm/#utils","title":"Utils","text":"<ul> <li>get_hierarchy_info.py</li> <li>query_brickschema.py</li> </ul>"},{"location":"modules/brickllm/#root-level-files","title":"Root-Level Files","text":"<ul> <li>compiled_graphs.py</li> <li>configs.py</li> <li>schemas.py</li> <li>states.py</li> </ul>"},{"location":"modules/edges/","title":"Edges Module","text":"<p>The <code>edges</code> module contains components related to the validation of relationships (edges) between entities in the graph.</p>"},{"location":"modules/edges/#contents","title":"Contents","text":"<ul> <li>validate_condition.py</li> </ul>"},{"location":"modules/graphs/","title":"Graphs Module","text":"<p>The <code>graphs</code> module contains components that manage and execute the BrickSchema graph operations.</p>"},{"location":"modules/graphs/#contents","title":"Contents","text":"<ul> <li>brickschema_graph.py</li> </ul>"},{"location":"modules/helpers/","title":"Helpers Module","text":"<p>The <code>helpers</code> module contains utility functions and prompts that assist in LLM interactions and data processing.</p>"},{"location":"modules/helpers/#contents","title":"Contents","text":"<ul> <li>llm_models.py</li> <li>prompts.py</li> </ul>"},{"location":"modules/nodes/","title":"Nodes Module","text":"<p>The <code>nodes</code> module contains specialized components that perform tasks such as element identification, hierarchy construction, and RDF conversion.</p>"},{"location":"modules/nodes/#contents","title":"Contents","text":"<ul> <li>get_elem_children.py</li> <li>get_elements.py</li> <li>get_relationships.py</li> <li>get_sensors.py</li> <li>schema_to_ttl.py</li> <li>validate_schema.py</li> </ul>"},{"location":"modules/ontologies/","title":"Ontologies Module","text":"<p>The <code>ontologies</code> module contains the BrickSchema and hierarchy files used for representing and managing the building systems.</p>"},{"location":"modules/ontologies/#contents","title":"Contents","text":"<ul> <li>brick_hierarchy.json</li> <li>Brick.ttl</li> </ul>"},{"location":"modules/utils/","title":"Utils Module","text":"<p>The <code>utils</code> module contains components related to querying and retrieving data from the BrickSchema.</p>"},{"location":"modules/utils/#contents","title":"Contents","text":"<ul> <li>get_hierarchy_info.py</li> <li>query_brickschema.py</li> </ul>"},{"location":"reference/brickllm/","title":"BrickLLM API Reference","text":"<p>Welcome to the API Reference for the <code>BrickLLM</code> library. This section of the documentation provides detailed information about the modules, classes, functions, and other components that make up the BrickLLM library.</p>"},{"location":"reference/brickllm/#overview","title":"Overview","text":"<p><code>BrickLLM</code> is a Python library designed to generate BrickSchema-compliant RDF files using Large Language Models (LLMs). It provides various utilities for parsing natural language building descriptions, extracting relevant components, and constructing a structured graph that represents the building and its systems.</p> <p>This API reference covers all the essential modules and functions available in the library, including components for:</p> <ul> <li>Element identification</li> <li>Relationship mapping</li> <li>TTL generation (Turtle format RDF)</li> <li>Ontology integration (BrickSchema)</li> </ul>"},{"location":"reference/brickllm/#key-modules","title":"Key Modules","text":"<ul> <li>Edges: Validation of relationships (edges) between entities in the graph.</li> <li>Graphs: Handles the orchestration of graph-based operations with the BrickSchema.</li> <li>Helpers: Contains utility functions and predefined LLM prompts to aid in the generation process.</li> <li>Nodes: Specialized nodes that handle various tasks such as extracting elements, constructing hierarchies, and generating RDF files.</li> <li>Ontologies: Includes the BrickSchema ontology and hierarchical data.</li> <li>Utils: Utility functions for querying the BrickSchema and handling RDF data.</li> </ul>"},{"location":"reference/brickllm/#how-to-use-the-api-reference","title":"How to Use the API Reference","text":"<ul> <li>Navigate to individual modules and components via the side navigation or by clicking on the links in the module overview sections.</li> <li>Each module contains a breakdown of its functions, classes, and attributes, with descriptions and examples where applicable.</li> </ul> <p>For an in-depth guide on how to use the library in practice, see the Usage section.</p> <p>Happy coding!</p>"},{"location":"reference/compiled_graphs/","title":"compiled_graphs.py","text":""},{"location":"reference/configs/","title":"configs.py","text":""},{"location":"reference/schemas/","title":"schemas.py","text":""},{"location":"reference/states/","title":"states.py","text":""},{"location":"reference/edges/validate_condition/","title":"validate_condition.py","text":""},{"location":"reference/edges/validate_condition/#brickllm.edges.validate_condition.validate_condition","title":"<code>validate_condition(state)</code>","text":"<p>Validate the condition for the next node to visit.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Dict[str, Any]</code> <p>The current state containing the validation result.</p> required <p>Returns:</p> Type Description <code>Literal['schema_to_ttl', '__end__']</code> <p>Literal[\"schema_to_ttl\", \"end\"]: The next node to visit.</p> Source code in <code>brickllm/edges/validate_condition.py</code> <pre><code>def validate_condition(state: Dict[str, Any]) -&gt; Literal[\"schema_to_ttl\", \"__end__\"]:\n    \"\"\"\n    Validate the condition for the next node to visit.\n\n    Args:\n        state (Dict[str, Any]): The current state containing the validation result.\n\n    Returns:\n        Literal[\"schema_to_ttl\", \"__end__\"]: The next node to visit.\n    \"\"\"\n\n    is_valid = state.get(\"is_valid\", False)\n    max_iter = state.get(\"validation_max_iter\", 0)\n\n    if max_iter &gt; 0 and not is_valid:\n        return \"schema_to_ttl\"\n\n    return \"__end__\"\n</code></pre>"},{"location":"reference/graphs/brickschema_graph/","title":"brickschema_graph.py","text":""},{"location":"reference/helpers/llm_models/","title":"llm_models.py","text":""},{"location":"reference/helpers/prompts/","title":"prompts.py","text":"<p>Module containing the prompts used for the LLM models</p>"},{"location":"reference/nodes/get_elem_children/","title":"get_elem_children.py","text":""},{"location":"reference/nodes/get_elem_children/#brickllm.nodes.get_elem_children.get_elem_children","title":"<code>get_elem_children(state, config)</code>","text":"<p>Identify child elements for each category in the element list using a language model.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The current state containing the user prompt and element list.</p> required <code>config</code> <code>dict</code> <p>Configuration dictionary containing the language model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the hierarchical structure of identified elements.</p> Source code in <code>brickllm/nodes/get_elem_children.py</code> <pre><code>def get_elem_children(state: State, config: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Identify child elements for each category in the element list using a language model.\n\n    Args:\n        state (State): The current state containing the user prompt and element list.\n        config (dict): Configuration dictionary containing the language model.\n\n    Returns:\n        dict: A dictionary containing the hierarchical structure of identified elements.\n    \"\"\"\n    custom_logger.eurac(\n        \"\ud83d\udcca Getting children for each BrickSchema category in the element list\"\n    )\n\n    user_prompt = state[\"user_prompt\"]\n    categories = state[\"elem_list\"]\n\n    category_dict = {}\n    for category in categories:\n        children_list = get_children_hierarchy(category, flatten=True)\n        children_string = \"\\n\".join(\n            [\n                f\"{parent} -&gt; {child}\"\n                for parent, child in children_list\n                if isinstance(parent, str) and isinstance(child, str)\n            ]\n        )\n        category_dict[category] = children_string\n\n    # Get the model name from the config\n    llm = config.get(\"configurable\", {}).get(\"llm_model\")\n\n    # Enforce structured output\n    structured_llm = llm.with_structured_output(ElemListSchema)\n\n    identified_children = []\n    for category in categories:\n        # if the category is not \"\\n\", then add the category to the prompt\n        if category_dict[category] != \"\":\n            # System message\n            system_message = get_elem_children_instructions.format(\n                prompt=user_prompt, elements_list=category_dict[category]\n            )\n            # Generate question\n            elements = structured_llm.invoke(\n                [SystemMessage(content=system_message)]\n                + [HumanMessage(content=\"Find the elements.\")]\n            )\n            identified_children.extend(elements.elem_list)\n        else:\n            identified_children.append(category)\n\n    # Remove duplicates\n    identified_children = list(set(identified_children))\n    filtered_children = filter_elements(identified_children)\n\n    # create hierarchical dictionary\n    hierarchical_dict = create_hierarchical_dict(filtered_children, properties=True)\n\n    return {\"elem_hierarchy\": hierarchical_dict}\n</code></pre>"},{"location":"reference/nodes/get_elements/","title":"get_elements.py","text":""},{"location":"reference/nodes/get_elements/#brickllm.nodes.get_elements.get_elements","title":"<code>get_elements(state, config)</code>","text":"<p>Process the user prompt to identify elements within specified categories using a language model.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The current state containing the user prompt.</p> required <code>config</code> <code>dict</code> <p>Configuration dictionary containing the language model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the list of identified elements.</p> Source code in <code>brickllm/nodes/get_elements.py</code> <pre><code>def get_elements(state: State, config: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Process the user prompt to identify elements within specified categories\n    using a language model.\n\n    Args:\n        state (State): The current state containing the user prompt.\n        config (dict): Configuration dictionary containing the language model.\n\n    Returns:\n        dict: A dictionary containing the list of identified elements.\n    \"\"\"\n    custom_logger.eurac(\"\ud83d\udd0d Getting elements from user prompt\")\n\n    user_prompt = state[\"user_prompt\"]\n\n    categories = [\"Point\", \"Equipment\", \"Location\", \"Collection\"]\n\n    category_dict = {}\n    # Get hierarchy info for each category\n    for category in categories:\n        parents, children = get_hierarchical_info(category)\n        # category_dict[category] = children\n\n        # get definition for each child\n        children_dict = {}\n        for child in children:\n            children_dict[child] = get_brick_definition(child)\n\n        category_dict[category] = children_dict\n\n    # Get the model name from the config\n    llm = config.get(\"configurable\", {}).get(\"llm_model\")\n\n    # Enforce structured output\n    structured_llm = llm.with_structured_output(ElemListSchema)\n\n    # System message\n    system_message = get_elem_instructions.format(\n        prompt=user_prompt, elements_dict=category_dict\n    )\n\n    # Generate question\n    answer = structured_llm.invoke(\n        [SystemMessage(content=system_message)]\n        + [HumanMessage(content=\"Find the elements.\")]\n    )\n\n    return {\"elem_list\": answer.elem_list}\n</code></pre>"},{"location":"reference/nodes/get_relationships/","title":"get_relationships.py","text":""},{"location":"reference/nodes/get_relationships/#brickllm.nodes.get_relationships.get_relationships","title":"<code>get_relationships(state, config)</code>","text":"<p>Determine relationships between building components using a language model.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The current state containing the user prompt and element hierarchy.</p> required <code>config</code> <code>dict</code> <p>Configuration dictionary containing the language model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the grouped sensor paths.</p> Source code in <code>brickllm/nodes/get_relationships.py</code> <pre><code>def get_relationships(state: State, config: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Determine relationships between building components using a language model.\n\n    Args:\n        state (State): The current state containing the user prompt and element hierarchy.\n        config (dict): Configuration dictionary containing the language model.\n\n    Returns:\n        dict: A dictionary containing the grouped sensor paths.\n    \"\"\"\n    custom_logger.eurac(\"\ud83d\udd17 Getting relationships between building components\")\n\n    user_prompt = state[\"user_prompt\"]\n    building_structure = state[\"elem_hierarchy\"]\n\n    # Convert building structure to a JSON string for better readability\n    building_structure_json = json.dumps(building_structure, indent=2)\n\n    # Get the model name from the config\n    llm = config.get(\"configurable\", {}).get(\"llm_model\")\n\n    # Enforce structured output\n    structured_llm = llm.with_structured_output(RelationshipsSchema)\n    # System message\n    system_message = get_relationships_instructions.format(\n        prompt=user_prompt, building_structure=building_structure_json\n    )\n\n    # Generate question\n    answer = structured_llm.invoke(\n        [SystemMessage(content=system_message)]\n        + [HumanMessage(content=\"Find the relationships.\")]\n    )\n\n    try:\n        tree_dict = build_hierarchy(answer.relationships)\n    except Exception as e:\n        print(f\"Error building the hierarchy: {e}\")\n\n    # Group sensors by their paths\n    sensor_paths = find_sensor_paths(tree_dict)\n    grouped_sensors = defaultdict(list)\n    for sensor in sensor_paths:\n        grouped_sensors[sensor[\"path\"]].append(sensor[\"name\"])\n    grouped_sensor_dict = dict(grouped_sensors)\n\n    return {\"sensors_dict\": grouped_sensor_dict}\n</code></pre>"},{"location":"reference/nodes/get_sensors/","title":"get_sensors.py","text":""},{"location":"reference/nodes/get_sensors/#brickllm.nodes.get_sensors.get_sensors","title":"<code>get_sensors(state)</code>","text":"<p>Retrieve sensor information for the building structure.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The current state.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing sensor UUIDs mapped to their locations.</p> Source code in <code>brickllm/nodes/get_sensors.py</code> <pre><code>def get_sensors(state: State) -&gt; Dict[str, Any]:\n    \"\"\"\n    Retrieve sensor information for the building structure.\n\n    Args:\n        state (State): The current state.\n\n    Returns:\n        dict: A dictionary containing sensor UUIDs mapped to their locations.\n    \"\"\"\n    custom_logger.eurac(\"\ud83d\udce1 Getting sensors information\")\n\n    uuid_dict = {\n        \"Building#1&gt;Floor#1&gt;Office#1&gt;Room#1\": [\n            {\n                \"name\": \"Temperature_Sensor#1\",\n                \"uuid\": \"aaaa-bbbb-cccc-dddd\",\n            },\n            {\n                \"name\": \"Humidity_Sensor#1\",\n                \"uuid\": \"aaaa-bbbb-cccc-dddd\",\n            },\n        ],\n        \"Building#1&gt;Floor#1&gt;Office#1&gt;Room#2\": [\n            {\n                \"name\": \"Temperature_Sensor#2\",\n                \"uuid\": \"aaaa-bbbb-cccc-dddd\",\n            },\n            {\n                \"name\": \"Humidity_Sensor#2\",\n                \"uuid\": \"aaaa-bbbb-cccc-dddd\",\n            },\n        ],\n    }\n    return {\"uuid_dict\": uuid_dict}\n</code></pre>"},{"location":"reference/nodes/schema_to_ttl/","title":"schema_to_ttl.py","text":""},{"location":"reference/nodes/schema_to_ttl/#brickllm.nodes.schema_to_ttl.schema_to_ttl","title":"<code>schema_to_ttl(state, config)</code>","text":"<p>Generate a TTL (Turtle) script from the building description and component hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The current state containing the user prompt, sensors, and element hierarchy.</p> required <code>config</code> <code>dict</code> <p>Configuration dictionary containing the language model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the generated TTL output.</p> Source code in <code>brickllm/nodes/schema_to_ttl.py</code> <pre><code>def schema_to_ttl(state: State, config: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Generate a TTL (Turtle) script from the building description and component hierarchy.\n\n    Args:\n        state (State): The current state containing the user prompt, sensors, and element hierarchy.\n        config (dict): Configuration dictionary containing the language model.\n\n    Returns:\n        dict: A dictionary containing the generated TTL output.\n    \"\"\"\n    custom_logger.eurac(\"\ud83d\udcdd Generating TTL from schema\")\n\n    user_prompt = state[\"user_prompt\"]\n    sensors_dict = state[\"sensors_dict\"]\n    elem_hierarchy = state[\"elem_hierarchy\"]\n\n    sensors_dict_json = json.dumps(sensors_dict, indent=2)\n    elem_hierarchy_json = json.dumps(elem_hierarchy, indent=2)\n\n    # Get the model name from the config\n    llm = config.get(\"configurable\", {}).get(\"llm_model\")\n\n    # Enforce structured output\n    structured_llm = llm.with_structured_output(TTLSchema)\n\n    # System message\n    system_message = schema_to_ttl_instructions.format(\n        prompt=user_prompt,\n        sensors_dict=sensors_dict_json,\n        elem_hierarchy=elem_hierarchy_json,\n        ttl_example=ttl_example,\n    )\n\n    # Generate question\n    answer = structured_llm.invoke(\n        [SystemMessage(content=system_message)]\n        + [HumanMessage(content=\"Generate the TTL.\")]\n    )\n\n    return {\"ttl_output\": answer.ttl_output}\n</code></pre>"},{"location":"reference/nodes/validate_schema/","title":"validate_schema.py","text":""},{"location":"reference/nodes/validate_schema/#brickllm.nodes.validate_schema.validate_schema","title":"<code>validate_schema(state)</code>","text":"<p>Validate the generated TTL output against the BrickSchema.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>The current state containing the TTL output and validation parameters.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>A dictionary containing the validation status and report.</p> Source code in <code>brickllm/nodes/validate_schema.py</code> <pre><code>def validate_schema(state) -&gt; Dict[str, Any]:\n    \"\"\"\n    Validate the generated TTL output against the BrickSchema.\n\n    Args:\n        state (State): The current state containing the TTL output and validation parameters.\n\n    Returns:\n        dict: A dictionary containing the validation status and report.\n    \"\"\"\n    custom_logger.eurac(\"\u2705 Validating TTL schema\")\n\n    ttl_output = state.get(\"ttl_output\", None)\n    max_iter = state.get(\"validation_max_iter\", 2)\n\n    max_iter -= 1\n\n    if ttl_output is None:\n        return {\n            \"is_valid\": False,\n            \"validation_report\": \"Empty TTL output.\",\n            \"validation_max_iter\": max_iter,\n        }\n\n    is_valid, report = validate_ttl(ttl_output)\n\n    return {\n        \"is_valid\": is_valid,\n        \"validation_report\": report,\n        \"validation_max_iter\": max_iter,\n    }\n</code></pre>"},{"location":"reference/ontologies/Brick/","title":"Brick.ttl","text":"<p>This file contains the BrickSchema ontology in Turtle (TTL) format.</p>"},{"location":"reference/ontologies/brick_hierarchy/","title":"brick_hierarchy.json","text":"<p>This file contains the hierarchical structure of the BrickSchema entities in JSON format.</p>"},{"location":"reference/utils/get_hierarchy_info/","title":"get_hierarchy_info.py","text":""},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.build_hierarchy","title":"<code>build_hierarchy(relationships)</code>","text":"<p>Build a hierarchical tree structure from a list of parent-child relationships.</p> <p>Parameters:</p> Name Type Description Default <code>relationships</code> <code>List[Tuple[str, str]]</code> <p>A list of tuples representing parent-child relationships.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representing the hierarchical tree structure.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def build_hierarchy(relationships: List[Tuple[str, str]]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Build a hierarchical tree structure from a list of parent-child relationships.\n\n    Args:\n        relationships (List[Tuple[str, str]]): A list of tuples representing parent-child relationships.\n\n    Returns:\n        Dict[str, Any]: A dictionary representing the hierarchical tree structure.\n    \"\"\"\n\n    # Helper function to recursively build the tree structure\n    def build_tree(node: str, tree_dict: Dict[str, List[str]]) -&gt; Dict[str, Any]:\n        return (\n            {\n                \"name\": node,\n                \"children\": [build_tree(child, tree_dict) for child in tree_dict[node]],\n            }\n            if tree_dict[node]\n            else {\"name\": node, \"children\": []}\n        )\n\n    # Create a dictionary to hold parent-children relationships\n    tree_dict: Dict[str, List[str]] = defaultdict(list)\n    nodes = set()\n\n    # Fill the dictionary with data from relationships\n    for parent, child in relationships:\n        tree_dict[parent].append(child)\n        nodes.update([parent, child])\n\n    # Find the root (a node that is never a child)\n    root_candidates = {\n        node for node in nodes if node not in {child for _, child in relationships}\n    }\n    if not root_candidates:\n        raise ValueError(\"No root found in relationships\")\n    root = next(iter(root_candidates))\n\n    # Build the hierarchical structure starting from the root\n    hierarchy = build_tree(root, tree_dict)\n    return hierarchy\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.create_hierarchical_dict","title":"<code>create_hierarchical_dict(elements, properties=False)</code>","text":"<p>Create a hierarchical dictionary from a list of elements, optionally including properties.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[str]</code> <p>A list of elements to include in the hierarchy.</p> required <code>properties</code> <code>bool</code> <p>Whether to include properties in the hierarchy. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representing the hierarchical structure.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def create_hierarchical_dict(\n    elements: List[str], properties: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Create a hierarchical dictionary from a list of elements, optionally including properties.\n\n    Args:\n        elements (List[str]): A list of elements to include in the hierarchy.\n        properties (bool, optional): Whether to include properties in the hierarchy. Defaults to False.\n\n    Returns:\n        Dict[str, Any]: A dictionary representing the hierarchical structure.\n    \"\"\"\n    hierarchy: Dict[str, Any] = {}\n\n    for category in elements:\n        parents, _ = get_hierarchical_info(category)\n        current_level = hierarchy\n\n        for parent in parents:\n            if parent not in current_level:\n                current_level[parent] = {}\n            current_level = current_level[parent]\n\n        # Finally add the category itself\n        if category not in current_level:\n            if properties:\n                elem_property = general_query(category)\n                if len(elem_property.keys()) == 0:\n                    continue\n                elem_property = elem_property[\"property\"]\n                # remove \"message\" key from the dictionary\n                for prop in elem_property.keys():\n                    elem_property[prop].pop(\"message\")\n                current_level[category] = {\"properties\": elem_property}\n            else:\n                current_level[category] = {}\n\n    return hierarchy\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.extract_ttl_content","title":"<code>extract_ttl_content(input_string)</code>","text":"<p>Extract content between code block markers in a string.</p> <p>Parameters:</p> Name Type Description Default <code>input_string</code> <code>str</code> <p>The input string containing code blocks.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The extracted content between the code block markers.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def extract_ttl_content(input_string: str) -&gt; str:\n    \"\"\"\n    Extract content between code block markers in a string.\n\n    Args:\n        input_string (str): The input string containing code blocks.\n\n    Returns:\n        str: The extracted content between the code block markers.\n    \"\"\"\n    # Use regex to match content between ```code and ```\n    match = re.search(r\"```code\\s*(.*?)\\s*```\", input_string, re.DOTALL)\n    if match:\n        return match.group(1).strip()\n    return \"\"\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.filter_elements","title":"<code>filter_elements(elements)</code>","text":"<p>Filter elements based on their hierarchical relationships.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[str]</code> <p>A list of elements to filter.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of filtered elements.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def filter_elements(elements: List[str]) -&gt; List[str]:\n    \"\"\"\n    Filter elements based on their hierarchical relationships.\n\n    Args:\n        elements (List[str]): A list of elements to filter.\n\n    Returns:\n        List[str]: A list of filtered elements.\n    \"\"\"\n    elements_info = {element: get_hierarchical_info(element) for element in elements}\n    filtered_elements = []\n\n    for element, (parents, children) in elements_info.items():\n        # Discard elements with no parents and no children\n        if not parents and not children:\n            continue\n        # Check if the element is a parent of any other element\n        is_parent = any(element in p_list for p_list, _ in elements_info.values())\n        if is_parent:\n            continue\n        filtered_elements.append(element)\n\n    return filtered_elements\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.find_parents","title":"<code>find_parents(current_data, target, parents=None)</code>","text":"<p>Recursively find the parent nodes of a target node in a hierarchical data structure.</p> <p>Parameters:</p> Name Type Description Default <code>current_data</code> <code>Dict[str, Any]</code> <p>The current level of the hierarchy to search.</p> required <code>target</code> <code>str</code> <p>The target node to find parents for.</p> required <code>parents</code> <code>Optional[List[str]]</code> <p>Accumulated list of parent nodes. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[bool, List[str]]</code> <p>Tuple[bool, List[str]]: A tuple containing a boolean indicating if the target was found and a list of parent nodes.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def find_parents(\n    current_data: Dict[str, Any], target: str, parents: Optional[List[str]] = None\n) -&gt; Tuple[bool, List[str]]:\n    \"\"\"\n    Recursively find the parent nodes of a target node in a hierarchical data structure.\n\n    Args:\n        current_data (Dict[str, Any]): The current level of the hierarchy to search.\n        target (str): The target node to find parents for.\n        parents (Optional[List[str]], optional): Accumulated list of parent nodes. Defaults to None.\n\n    Returns:\n        Tuple[bool, List[str]]: A tuple containing a boolean indicating if the target was found and a list of parent nodes.\n    \"\"\"\n    if parents is None:\n        parents = []\n    for key, value in current_data.items():\n        if key == target:\n            return True, parents\n        if isinstance(value, dict):\n            found, result = find_parents(value, target, parents + [key])\n            if found:\n                return True, result\n    return False, []\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.find_sensor_paths","title":"<code>find_sensor_paths(tree, path=None)</code>","text":"<p>Find paths to sensor nodes in a hierarchical tree structure.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>Dict[str, Any]</code> <p>The hierarchical tree structure.</p> required <code>path</code> <code>Optional[List[str]]</code> <p>Accumulated path to the current node. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List[Dict[str, str]]: A list of dictionaries containing sensor names and their paths.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def find_sensor_paths(\n    tree: Dict[str, Any], path: Optional[List[str]] = None\n) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Find paths to sensor nodes in a hierarchical tree structure.\n\n    Args:\n        tree (Dict[str, Any]): The hierarchical tree structure.\n        path (Optional[List[str]], optional): Accumulated path to the current node. Defaults to None.\n\n    Returns:\n        List[Dict[str, str]]: A list of dictionaries containing sensor names and their paths.\n    \"\"\"\n    if path is None:\n        path = []\n\n    current_path = path + [tree.get(\"name\", \"\")]\n    if \"children\" not in tree or not tree[\"children\"]:\n        if re.search(r\"Sensor\", tree.get(\"name\", \"\")):\n            sensor_path = \"&gt;\".join(current_path[:-1])\n            return [{\"name\": tree.get(\"name\", \"\"), \"path\": sensor_path}]\n        return []\n\n    sensor_paths = []\n    for child in tree[\"children\"]:\n        sensor_paths.extend(find_sensor_paths(child, current_path))\n\n    return sensor_paths\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.flatten_hierarchy","title":"<code>flatten_hierarchy(current_data, parent=None, result=None)</code>","text":"<p>Flatten a hierarchical data structure into a list of parent-child tuples.</p> <p>Parameters:</p> Name Type Description Default <code>current_data</code> <code>Dict[str, Any]</code> <p>The current level of the hierarchy to flatten.</p> required <code>parent</code> <code>Optional[str]</code> <p>The parent node. Defaults to None.</p> <code>None</code> <code>result</code> <code>Optional[List[Tuple[str, str]]]</code> <p>Accumulated list of parent-child tuples. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Tuple[str, str]]</code> <p>List[Tuple[str, str]]: A list of tuples representing parent-child relationships.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def flatten_hierarchy(\n    current_data: Dict[str, Any],\n    parent: Optional[str] = None,\n    result: Optional[List[Tuple[str, str]]] = None,\n) -&gt; List[Tuple[str, str]]:\n    \"\"\"\n    Flatten a hierarchical data structure into a list of parent-child tuples.\n\n    Args:\n        current_data (Dict[str, Any]): The current level of the hierarchy to flatten.\n        parent (Optional[str], optional): The parent node. Defaults to None.\n        result (Optional[List[Tuple[str, str]]], optional): Accumulated list of parent-child tuples. Defaults to None.\n\n    Returns:\n        List[Tuple[str, str]]: A list of tuples representing parent-child relationships.\n    \"\"\"\n    if result is None:\n        result = []\n    for key, value in current_data.items():\n        if parent:\n            result.append((parent, key))\n        if isinstance(value, dict):\n            flatten_hierarchy(value, key, result)\n    return result\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.get_all_subchildren","title":"<code>get_all_subchildren(current_data, target)</code>","text":"<p>Recursively get all children and subchildren of a target node.</p> <p>Parameters:</p> Name Type Description Default <code>current_data</code> <code>Dict[str, Any]</code> <p>The current level of the hierarchy to search.</p> required <code>target</code> <code>str</code> <p>The target node to find children for.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representing the subtree of the target node.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def get_all_subchildren(current_data: Dict[str, Any], target: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Recursively get all children and subchildren of a target node.\n\n    Args:\n        current_data (Dict[str, Any]): The current level of the hierarchy to search.\n        target (str): The target node to find children for.\n\n    Returns:\n        Dict[str, Any]: A dictionary representing the subtree of the target node.\n    \"\"\"\n    if target in current_data:\n        sub_tree = current_data[target]\n        if isinstance(sub_tree, dict):\n            return sub_tree\n        else:\n            return {}\n    for key, value in current_data.items():\n        if isinstance(value, dict):\n            result = get_all_subchildren(value, target)\n            if result:\n                return result\n    return {}\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.get_children","title":"<code>get_children(current_data, target)</code>","text":"<p>Get the children of a target node in a hierarchical data structure.</p> <p>Parameters:</p> Name Type Description Default <code>current_data</code> <code>Dict[str, Any]</code> <p>The current level of the hierarchy to search.</p> required <code>target</code> <code>str</code> <p>The target node to find children for.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of child nodes.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def get_children(current_data: Dict[str, Any], target: str) -&gt; List[str]:\n    \"\"\"\n    Get the children of a target node in a hierarchical data structure.\n\n    Args:\n        current_data (Dict[str, Any]): The current level of the hierarchy to search.\n        target (str): The target node to find children for.\n\n    Returns:\n        List[str]: A list of child nodes.\n    \"\"\"\n    if target in current_data:\n        return list(current_data[target].keys())\n    for key, value in current_data.items():\n        if isinstance(value, dict):\n            children = get_children(value, target)\n            if children:\n                return children\n    return []\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.get_children_hierarchy","title":"<code>get_children_hierarchy(key, flatten=False)</code>","text":"<p>Get the hierarchy of children for a target node, optionally flattening the result.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The target node to get children for.</p> required <code>flatten</code> <code>bool</code> <p>Whether to flatten the hierarchy. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Dict[str, Any], List[Tuple[str, str]]]</code> <p>Union[Dict[str, Any], List[Tuple[str, str]]]: A dictionary representing the hierarchy or a list of parent-child tuples if flattened.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def get_children_hierarchy(\n    key: str, flatten: bool = False\n) -&gt; Union[Dict[str, Any], List[Tuple[str, str]]]:\n    \"\"\"\n    Get the hierarchy of children for a target node, optionally flattening the result.\n\n    Args:\n        key (str): The target node to get children for.\n        flatten (bool, optional): Whether to flatten the hierarchy. Defaults to False.\n\n    Returns:\n        Union[Dict[str, Any], List[Tuple[str, str]]]: A dictionary representing the hierarchy or a list of parent-child tuples if flattened.\n    \"\"\"\n    if flatten:\n        return flatten_hierarchy(get_all_subchildren(data, key))\n    return get_all_subchildren(data, key)\n</code></pre>"},{"location":"reference/utils/get_hierarchy_info/#brickllm.utils.get_hierarchy_info.get_hierarchical_info","title":"<code>get_hierarchical_info(key)</code>","text":"<p>Get the hierarchical information of a node, including its parents and children.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The target node to get information for.</p> required <p>Returns:</p> Type Description <code>Tuple[List[str], List[str]]</code> <p>Tuple[List[str], List[str]]: A tuple containing a list of parent nodes and a list of child nodes.</p> Source code in <code>brickllm/utils/get_hierarchy_info.py</code> <pre><code>def get_hierarchical_info(key: str) -&gt; Tuple[List[str], List[str]]:\n    \"\"\"\n    Get the hierarchical information of a node, including its parents and children.\n\n    Args:\n        key (str): The target node to get information for.\n\n    Returns:\n        Tuple[List[str], List[str]]: A tuple containing a list of parent nodes and a list of child nodes.\n    \"\"\"\n    # Get parents\n    found, parents = find_parents(data, key)\n    # Get children\n    children = get_children(data, key)\n    return (parents, children)\n</code></pre>"},{"location":"reference/utils/query_brickschema/","title":"query_brickschema.py","text":""},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.clean_result","title":"<code>clean_result(data)</code>","text":"<p>Extract the relevant part of a URI from a list of data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[str]</code> <p>A list of URIs to clean.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of extracted parts from the URIs.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def clean_result(data: List[str]) -&gt; List[str]:\n    \"\"\"\n    Extract the relevant part of a URI from a list of data.\n\n    Args:\n        data (List[str]): A list of URIs to clean.\n\n    Returns:\n        List[str]: A list of extracted parts from the URIs.\n    \"\"\"\n    return [\n        re.findall(r\"#(\\w+)\", value)[0]\n        for value in data\n        if re.findall(r\"#(\\w+)\", value)\n    ]\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.general_query","title":"<code>general_query(element)</code>","text":"<p>Retrieve properties and relationships for a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element to retrieve properties and relationships for.</p> required <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Union[str, List[str]]]]</code> <p>Dict[str, Dict[str, Union[str, List[str]]]]: A dictionary containing properties and their constraints.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def general_query(element: str) -&gt; Dict[str, Dict[str, Union[str, List[str]]]]:\n    \"\"\"\n    Retrieve properties and relationships for a given element.\n\n    Args:\n        element (str): The element to retrieve properties and relationships for.\n\n    Returns:\n        Dict[str, Dict[str, Union[str, List[str]]]]: A dictionary containing properties and their constraints.\n    \"\"\"\n    subclasses = iterative_subclasses(element)\n    if not subclasses:\n        return {}\n\n    query_data = get_query_result(query_properties(subclasses[-1]))\n    relationships: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n\n    for row in query_data:\n        property_name = clean_result([row[\"path\"]])[0]\n        if property_name not in relationships:\n            relationships[property_name] = {\n                \"message\": row[\"message\"],\n                \"constraint\": clean_result([row[\"class\"]]),\n            }\n        else:\n            if isinstance(relationships[property_name][\"constraint\"], list):\n                relationships[property_name][\"constraint\"].extend(\n                    clean_result([row[\"class\"]])\n                )\n            else:\n                relationships[property_name][\"constraint\"] = clean_result(\n                    [row[\"class\"]]\n                )\n\n    return {\"property\": relationships}\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.get_brick_definition","title":"<code>get_brick_definition(element_name)</code>","text":"<p>Get the definition of an element from the Brick schema Turtle file.</p> <p>Parameters:</p> Name Type Description Default <code>element_name</code> <code>str</code> <p>The name of the element to get the definition for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The definition of the element, or \"No definition available\" if not found.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def get_brick_definition(element_name: str) -&gt; str:\n    \"\"\"\n    Get the definition of an element from the Brick schema Turtle file.\n\n    Args:\n        element_name (str): The name of the element to get the definition for.\n\n    Returns:\n        str: The definition of the element, or \"No definition available\" if not found.\n    \"\"\"\n    normalized_key = element_name.replace(\"_\", \"\").lower()\n    for prefix, namespace in namespaces.items():\n        uri = namespace[element_name]\n        for s, p, o in g.triples(\n            (uri, URIRef(\"http://www.w3.org/2004/02/skos/core#definition\"), None)\n        ):\n            return str(o)\n        uri = namespace[normalized_key]\n        for s, p, o in g.triples(\n            (uri, URIRef(\"http://www.w3.org/2004/02/skos/core#definition\"), None)\n        ):\n            return str(o)\n    return \"No definition available\"\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.get_query_result","title":"<code>get_query_result(query)</code>","text":"<p>Execute a SPARQL query on the Brick schema graph and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SPARQL query to execute.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>List[Dict[str, str]]: A list of dictionaries representing the query results.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def get_query_result(query: str) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Execute a SPARQL query on the Brick schema graph and return the results.\n\n    Args:\n        query (str): The SPARQL query to execute.\n\n    Returns:\n        List[Dict[str, str]]: A list of dictionaries representing the query results.\n    \"\"\"\n    result = g.query(query)\n    # Convert the result to a list of dictionaries where keys are the variable names\n    query_vars = list(result.vars) if result.vars is not None else []\n    data: List[Dict[str, Optional[str]]] = []\n    for row in result:\n        if isinstance(row, ResultRow):\n            data.append(\n                {str(var): str(row[var]) if row[var] else None for var in query_vars}\n            )\n    # Remove entries with None values and reset index\n    cleaned_data = [\n        {key: value for key, value in row.items() if value is not None} for row in data\n    ]\n    return cleaned_data\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.iterative_subclasses","title":"<code>iterative_subclasses(element)</code>","text":"<p>Iteratively find all subclasses of a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element to find subclasses for.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of subclasses.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def iterative_subclasses(element: str) -&gt; List[str]:\n    \"\"\"\n    Iteratively find all subclasses of a given element.\n\n    Args:\n        element (str): The element to find subclasses for.\n\n    Returns:\n        List[str]: A list of subclasses.\n    \"\"\"\n    subclasses: List[str] = []\n    sub_class_data = get_query_result(query_subclass(element))\n    subClass = (\n        clean_result([row[\"subclass\"] for row in sub_class_data])\n        if sub_class_data\n        else []\n    )\n\n    while subClass:\n        subclasses.append(subClass[0])\n        if subClass[0] in {\n            \"Collection\",\n            \"Equipment\",\n            \"Location\",\n            \"Measureable\",\n            \"Point\",\n        }:\n            break\n        sub_class_data = get_query_result(query_subclass(subClass[0]))\n        subClass = (\n            clean_result([row[\"subclass\"] for row in sub_class_data])\n            if sub_class_data\n            else []\n        )\n\n    return subclasses\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.query_properties","title":"<code>query_properties(element)</code>","text":"<p>Create a SPARQL query to find properties of a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element to find properties for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The SPARQL query string.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def query_properties(element: str) -&gt; str:\n    \"\"\"\n    Create a SPARQL query to find properties of a given element.\n\n    Args:\n        element (str): The element to find properties for.\n\n    Returns:\n        str: The SPARQL query string.\n    \"\"\"\n    return f\"\"\"\n    SELECT ?property ?message ?path ?class WHERE {{\n        brick:{element} sh:property ?property .\n        ?property sh:message ?message ; sh:path ?path ;\n                  sh:or/rdf:rest*/rdf:first ?constraint .\n        ?constraint sh:class ?class .\n    }}\n    \"\"\"\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.query_subclass","title":"<code>query_subclass(element)</code>","text":"<p>Create a SPARQL query to find subclasses of a given element.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>str</code> <p>The element to find subclasses for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The SPARQL query string.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def query_subclass(element: str) -&gt; str:\n    \"\"\"\n    Create a SPARQL query to find subclasses of a given element.\n\n    Args:\n        element (str): The element to find subclasses for.\n\n    Returns:\n        str: The SPARQL query string.\n    \"\"\"\n    return f\"SELECT ?subclass WHERE {{ brick:{element} rdfs:subClassOf ?subclass . }}\"\n</code></pre>"},{"location":"reference/utils/query_brickschema/#brickllm.utils.query_brickschema.validate_ttl","title":"<code>validate_ttl(ttl_file, method='pyshacl')</code>","text":"<p>Validate a TTL file using the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>ttl_file</code> <code>str</code> <p>The TTL file to validate.</p> required <code>method</code> <code>str</code> <p>The method to use for validation. Default is 'pyshacl'.</p> <code>'pyshacl'</code> <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>Tuple[bool, str]: A tuple containing a boolean indicating if the validation was successful and a validation report or error message.</p> Source code in <code>brickllm/utils/query_brickschema.py</code> <pre><code>def validate_ttl(ttl_file: str, method: str = \"pyshacl\") -&gt; Tuple[bool, str]:\n    \"\"\"\n    Validate a TTL file using the specified method.\n\n    Args:\n        ttl_file (str): The TTL file to validate.\n        method (str): The method to use for validation. Default is 'pyshacl'.\n\n    Returns:\n        Tuple[bool, str]: A tuple containing a boolean indicating if the validation was successful and a validation report or error message.\n    \"\"\"\n    # Load the ttl file\n    output_graph = Graph()\n    try:\n        output_graph.parse(StringIO(ttl_file), format=\"ttl\")\n    except Exception as e:\n        return False, f\"Failed to parse the TTL file. Content: {e}\"\n\n    if method == \"pyshacl\":\n        valid, results_graph, report = pyshacl.validate(\n            output_graph,\n            shacl_graph=g,\n            ont_graph=g,\n            inference=\"rdfs\",\n            abort_on_first=False,\n            allow_infos=False,\n            allow_warnings=False,\n            meta_shacl=False,\n            advanced=False,\n            js=False,\n            debug=False,\n        )\n        return valid, report\n    else:\n        return False, \"Method not found\"\n</code></pre>"}]}